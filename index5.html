<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>ç­”æ¡ˆæƒæå™¨</title>
  <style>
    body { font-family: sans-serif; max-width: 800px; margin: auto; text-align: center; }
    .red-frame { position: absolute; top: 25%; left: 25%; width: 50%; height: 50%; border: 4px solid red; }
    .relative { position: relative; }
    video { width: 100%; }
    button, select, input[type="file"] { margin: 8px; padding: 8px 16px; font-size: 16px; }
    img.preview { max-width: 100%; margin-top: 8px; }
    canvas { max-width: 100%; margin-top: 8px; border: 1px solid #ccc; }
  </style>
  <!-- Vue -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <!-- SheetJS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
</head>
<body>

<div id="app">
  <h2>ç­”æ¡ˆæƒæå™¨ Demo</h2>

  <!-- å°‡canvasæ”¹æˆé¡¯ç¤ºï¼Œæ–¹ä¾¿çœ‹åˆ°ç´…æ¡† -->
  <canvas ref="canvas"></canvas>

  <div>
    <!--<button @click="capture">é–‹å§‹æƒæï¼ˆç›¸æ©Ÿï¼‰</button>-->
    <input type="file" accept="image/*" @change="handleFile">
	<select v-model="exportMode">
	  <option value="both">é›™é‡æˆç«‹</option>
	  <option value="pixel">åƒç´ å·®ç•°æ³•</option>
	  <option value="template">æ¨¡æ¿æ¯”å°æ³•</option>
	</select>
    <button @click="exportExcel">åŒ¯å‡º Excel</button>
  </div>

<img id="templateImg" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAkACQAAD/2wBDAAIBAQIBAQICAgICAgICAwUDAwMDAwYEBAMFBwYHBwcGBwcICQsJCAgKCAcHCg0KCgsMDAwMBwkODw0MDgsMDAz/2wBDAQICAgMDAwYDAwYMCAcIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wAARCABGAF0DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9/KKKKACiiigAopC2DTZJQqZyPWgB9FMjcOxwQdpwfY/5xT6ACiiigAooooAKKKKACkfpS01zgUAfLH/BWb/gqh4J/wCCTn7OcPjjxdpupa9faxdnTNC0azwh1G82NIFkmOVhiUKS8m1yo+6jkhT/ADS/8FDv+C3f7Wf7W3jTSvGWr+KfHPwp8G6utxJ4W0rwvd3ui6VPAkgSR0uFZTfSIy7WlZmCuCEEanYP6p/2pf2I/hV+2nB4Yt/ip4L0vxtZeEdS/tbS7XUfMe2hufLZN8kQYRzJtYgxyo6E4JXKgj8Hf+D1zSrbQfjt8ArKzt4LK1tvDWoRw20MYjit0WeFQqAAAJhcAADoexFAH6tf8G33xJ8Q/F//AII1/B/xH4q13W/E2u6iNZFxqmr30l9eXQj1zUIk8yaQl22oiqATwqgV9yV8Af8ABrn/AMoKPgZ/3Hv/AFINSr7/AKACiiigAooooAKKKKACiikbpQAE81/OZ/we9f8AJx/wH/7FrUv/AEqir9Xv+C3v/BWC5/4JEfs6+F/HVt4Ig8eyeI/EiaD9gl1T+zljBtriff5gikyR5IAGDndX83P/AAWh/wCCxd3/AMFhviD4I1+88CWvgI+CrC509IrfVzqH2pZZlk3HMUWMbR25yfSgD+h3/g10OP8AghR8DP8AuPf+pBqdff8AX8u//BMb/g6W1D/gnD+xV4H+C9t8GrPxbaeEWvQdYfxGbSSf7TqFxeH9wLZxlftG0fOc461/UBYhtnzjDEDIByF9gcDIHPagCxRRRQAUUUUAFFFFABTZOn406igDmfib8J/DPxi0aLS/FvhrQvFOlxTC4W01axivIEkAKiQJIrLuAZhn0Y+tcPa/sI/BADafgz8Kl24+UeErEDOB0HlY9K9eooA8mh/YY+C2n3Uc9v8ACD4XQzRHcskfhSwV1PbB8rPvx3Ar1KzjMeQc/UgAn8uPb8Pep6KACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//9k=" style="display: none;">
<!--<img id="nullImg" style="display: none;" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAkACQAAD/2wBDAAIBAQIBAQICAgICAgICAwUDAwMDAwYEBAMFBwYHBwcGBwcICQsJCAgKCAcHCg0KCgsMDAwMBwkODw0MDgsMDAz/2wBDAQICAgMDAwYDAwYMCAcIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wAARCABZAF8DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9/BxRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH/2Q==">
-->
<img id="nullImg" style="display: none;" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAkACQAAD/2wBDAAIBAQIBAQICAgICAgICAwUDAwMDAwYEBAMFBwYHBwcGBwcICQsJCAgKCAcHCg0KCgsMDAwMBwkODw0MDgsMDAz/2wBDAQICAgMDAwYDAwYMCAcIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wAARCABCAEwDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/2Q==">
 <!--<img id="nullImg" style="display: none;" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAkACQAAD/2wBDAAIBAQIBAQICAgICAgICAwUDAwMDAwYEBAMFBwYHBwcGBwcICQsJCAgKCAcHCg0KCgsMDAwMBwkODw0MDgsMDAz/2wBDAQICAgMDAwYDAwYMCAcIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wAARCAAnAC0DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Z">
   -->
  <div v-if="uploadedImage">
    <h3>ä¸Šå‚³åœ–ç‰‡é è¦½</h3>
    <img :src="uploadedImage" class="preview">
  </div>

  <!--<div v-if="detected.length > 0">
    <h3>åµæ¸¬çµæœ (å‰10é¡Œé è¦½)</h3>
    <div v-for="row in detected.slice(0,10)" :key="row.question">
      ç¬¬ {{ row.question }} é¡Œï¼šA={{row.A}} B={{row.B}} C={{row.C}} D={{row.D}}
    </div>
    <p>... å…± {{detected.length}} é¡Œ</p>
  </div>-->
</div>

<script>
// ç­‰ OpenCV è¼‰å…¥å®Œæˆå†å•Ÿå‹• Vue
Module = {
  onRuntimeInitialized() {
    console.log('OpenCV ready!')
    startVue()
  }
}

function startVue() {
const { createApp, ref, onMounted } = Vue

createApp({
  setup() {
    const video = ref(null)
    const canvas = ref(null)
    const detected_pixel = ref([])
	const detected_template = ref([])
    const devices = ref([])
    const selectedDeviceId = ref('')
    const uploadedImage = ref(null)
	const exportMode = ref('both') // é è¨­ç‚ºé›™é‡æˆç«‹

    let currentStream = null

    const handleFile = (e) => {
      const file = e.target.files[0]
      if (!file) return
      const reader = new FileReader()
      reader.onload = () => {
        uploadedImage.value = reader.result
        const img = new Image()
        img.onload = () => {
          const ctx = canvas.value.getContext('2d')
          canvas.value.width = img.width
          canvas.value.height = img.height
          ctx.drawImage(img, 0, 0)
          const imageData = ctx.getImageData(0, 0, img.width, img.height)
          processImage(imageData)
        }
        img.src = reader.result
      }
      reader.readAsDataURL(file)
    }

/*
function deskewAndCropImage(src) {
  let gray = new cv.Mat();
  let binary = new cv.Mat();
  let contours = new cv.MatVector();
  let hierarchy = new cv.Mat();

  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.threshold(gray, binary, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);

  cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  let maxContour = null;
  let maxArea = 0;
  for (let i = 0; i < contours.size(); i++) {
    let cnt = contours.get(i);
    let area = cv.contourArea(cnt);
    if (area > maxArea) {
      maxArea = area;
      maxContour = cnt;
    }
  }

  if (!maxContour || maxContour.rows < 5) {
    console.warn('âš ï¸ æ‰¾ä¸åˆ°æœ€å¤§è¼ªå»“');
    gray.delete(); binary.delete(); contours.delete(); hierarchy.delete();
    return src.clone();
  }

  // å…ˆç”¨æ—‹è½‰çŸ©å½¢å–å¾—è§’åº¦
  let rotatedRect = cv.minAreaRect(maxContour);
  let angle = rotatedRect.angle;
  if (rotatedRect.size.width < rotatedRect.size.height) {
    angle += 90;
  }

  // æ—‹è½‰æ•´å¼µåœ–ç‰‡ï¼Œä½¿è¡¨æ ¼å›æ­£
  let center = new cv.Point(src.cols / 2, src.rows / 2);
  let M_rotate = cv.getRotationMatrix2D(center, angle, 1);
  let rotated = new cv.Mat();
  cv.warpAffine(src, rotated, M_rotate, new cv.Size(src.cols, src.rows), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(255,255,255,255));

  // æ—‹è½‰å¾Œå†åšç°éšäºŒå€¼åŒ–ï¼Œæ‰¾æœ€å¤§è¼ªå»“ä¸¦è£åˆ‡
  let gray2 = new cv.Mat();
  let binary2 = new cv.Mat();
  let contours2 = new cv.MatVector();
  let hierarchy2 = new cv.Mat();

  cv.cvtColor(rotated, gray2, cv.COLOR_RGBA2GRAY);
  cv.threshold(gray2, binary2, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
  cv.findContours(binary2, contours2, hierarchy2, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  let maxContour2 = null;
  let maxArea2 = 0;
  for (let i = 0; i < contours2.size(); i++) {
    let cnt = contours2.get(i);
    let area = cv.contourArea(cnt);
    if (area > maxArea2) {
      maxArea2 = area;
      maxContour2 = cnt;
    }
  }

  if (!maxContour2 || maxContour2.rows < 5) {
    console.warn('âš ï¸ æ—‹è½‰å¾Œæ‰¾ä¸åˆ°æœ€å¤§è¼ªå»“');
    // é‡‹æ”¾è³‡æº
    gray.delete(); binary.delete(); contours.delete(); hierarchy.delete();
    gray2.delete(); binary2.delete(); contours2.delete(); hierarchy2.delete();
    M_rotate.delete();
    return rotated.clone();
  }

  // ç”¨ boundingRect è£åˆ‡
  let rect = cv.boundingRect(maxContour2);
  let cropped = rotated.roi(rect);

  // é‡‹æ”¾è³‡æº
  gray.delete(); binary.delete(); contours.delete(); hierarchy.delete();
  gray2.delete(); binary2.delete(); contours2.delete(); hierarchy2.delete();
  M_rotate.delete();

  return cropped.clone();
}



function sortVertices(pts) {
  // æ±‚å‡ºè³ªå¿ƒ
  let center = pts.reduce((acc, pt) => ({ x: acc.x + pt.x, y: acc.y + pt.y }), { x: 0, y: 0 })
  center.x /= pts.length
  center.y /= pts.length

  // åˆ†åˆ¥æ ¹æ“šè§’åº¦é€²è¡Œæ’åºï¼štop-left â†’ top-right â†’ bottom-right â†’ bottom-left
  return pts.sort((a, b) => {
    let angleA = Math.atan2(a.y - center.y, a.x - center.x)
    let angleB = Math.atan2(b.y - center.y, b.x - center.x)
    return angleA - angleB
  })
}
*/


function deskewAndCropImage(src) {
  let gray = new cv.Mat();
  let binary = new cv.Mat();
  let contours = new cv.MatVector();
  let hierarchy = new cv.Mat();

  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
  cv.threshold(gray, binary, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU);
  cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  let maxContour = null;
  let maxArea = 0;
  for (let i = 0; i < contours.size(); i++) {
    let cnt = contours.get(i);
    let area = cv.contourArea(cnt);
    if (area > maxArea) {
      maxArea = area;
      maxContour = cnt;
    }
  }

  if (!maxContour || maxContour.rows < 5) {
    console.warn('âš ï¸ æ‰¾ä¸åˆ°æœ€å¤§è¼ªå»“');
    gray.delete(); binary.delete(); contours.delete(); hierarchy.delete();
    return src.clone();
  }

  // å–å¾—æ—‹è½‰çŸ©å½¢èˆ‡4é»åº§æ¨™
  let rotatedRect = cv.minAreaRect(maxContour);
  let vertices = getRotatedRectPoints(rotatedRect); // å›å‚³ cv.Point[4]ï¼Œé †æ™‚é‡

  // ç›®æ¨™å¯¬é«˜ï¼ˆä½¿ç”¨é•·é‚Šç‚ºå¯¬ï¼‰
  let width = Math.round(Math.hypot(vertices[0].x - vertices[1].x, vertices[0].y - vertices[1].y));
  let height = Math.round(Math.hypot(vertices[1].x - vertices[2].x, vertices[1].y - vertices[2].y));

  // æºé»ï¼ˆç›®å‰åœ–ä¸Šçš„4å€‹é»ï¼‰æ‰“åŒ…æˆä¸€å€‹ç¬¦åˆ OpenCV æ ¼å¼çš„æµ®é»æ•¸åº§æ¨™é™£åˆ—
  let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
    vertices[0].x, vertices[0].y,
    vertices[1].x, vertices[1].y,
    vertices[2].x, vertices[2].y,
    vertices[3].x, vertices[3].y
  ]);

  // ç›®æ¨™é»ï¼ˆè½‰æˆæ°´å¹³çš„çŸ©å½¢ï¼‰ç›®æ¨™çŸ©é™£ çŸ©å½¢çš„å·¦ä¸Šä¸€å®šæ˜¯0 0ç„¶å¾Œä¾é•·å¯¬æ‰¾å‡º æ–°çŸ©å½¢4é»åº§æ¨™
  let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
    0, 0,
    width, 0,
    width, height,
    0, height
  ]);

  let M = cv.getPerspectiveTransform(srcTri, dstTri); //å–å¾—è½‰æ›å…¬å¼
  let dst = new cv.Mat();
  //M æ˜¯å‰›æ‰ç®—å‡ºä¾†çš„é€è¦–è®Šæ›çŸ©é™£ 
  //new cv.Size(width, height) æ˜¯ä½ è¦è¼¸å‡ºçš„åœ–åƒå¤§å°
  //cv.warpPerspective æœƒæ ¹æ“šçŸ©é™£ Mï¼Œå¾åŸåœ– src æ“·å–ä¸¦ã€Œæ ¡æ­£æ‹‰ä¼¸ã€å‡ºä¸€å¼µæ–°çš„åœ– dstï¼Œé€™å¼µåœ–å°±æ˜¯ã€Œç­”æ¡ˆè¡¨æ ¼çš„æ­£å‘çŸ©å½¢å€åŸŸã€
  cv.warpPerspective(src, dst, M, new cv.Size(width, height), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar(255,255,255,255));

  // æ¸…ç†
  gray.delete(); binary.delete(); contours.delete(); hierarchy.delete();
  srcTri.delete(); dstTri.delete(); M.delete();

  return dst; // âœ… å›å‚³æ“·å–å‡ºä¾† + å·²ç¶“è½‰æ­£çš„ç­”æ¡ˆè¡¨æ ¼
}



function getRotatedRectPoints(rotatedRect) {
  let angleRad = rotatedRect.angle * Math.PI / 180.0;
  let b = Math.cos(angleRad) * 0.5;
  let a = Math.sin(angleRad) * 0.5;

  let center = rotatedRect.center;
  let size = rotatedRect.size;

  let pt0 = new cv.Point(
    center.x - a * size.height - b * size.width,
    center.y + b * size.height - a * size.width
  );
  let pt1 = new cv.Point(
    center.x + a * size.height - b * size.width,
    center.y - b * size.height - a * size.width
  );
  let pt2 = new cv.Point(
    2 * center.x - pt0.x,
    2 * center.y - pt0.y
  );
  let pt3 = new cv.Point(
    2 * center.x - pt1.x,
    2 * center.y - pt1.y
  );

  return [pt0, pt1, pt2, pt3];
}



    const processImage = (imageData) => {
	
		let src = cv.matFromImageData(imageData)
		// ğŸ” STEP 1: å…ˆç•«å‡ºåµæ¸¬åˆ°çš„ç´…æ¡†ï¼ˆç¢ºèªè¡¨æ ¼æœ‰æŠ“åˆ°ï¼‰
		  let preview = deskewAndCropImage(src);
		  //cv.imshow(canvas.value, preview); // é¡¯ç¤ºç•«æœ‰ç´…æ¡†çš„åœ–
		  src.delete();
		  //preview.delete();

		  //return; // æš«åœæµç¨‹ï¼Œç¢ºèªç´…æ¡†å°ä¸å°ï¼Œå†åšå¾ŒçºŒå‹•ä½œ
		src = preview;
		
		
		
		
		
		//src.delete() // åŸåœ–ä¸å†ä½¿ç”¨ï¼Œé‡‹æ”¾
		//src = aligned


		let gray = new cv.Mat()
		let thresh = new cv.Mat()
		cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY)
		cv.threshold(gray, thresh, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU)
	
	
      //let src = cv.matFromImageData(imageData)
      //let gray = new cv.Mat()
      //let thresh = new cv.Mat()
      //cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY)
      //cv.threshold(gray, thresh, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU)

      const numBlocks = 4
      const questionsPerBlock = 25
      const rowsPerBlock = 26   // å«æ¨™é¡Œè¡Œ
      const colsPerBlock = 5    // é¡Œè™Ÿ+ABCD

      const blockW = Math.floor(thresh.cols / numBlocks)
      const blockH = thresh.rows

      const cellH = Math.floor(blockH / rowsPerBlock) * 1.005
      const cellW = Math.floor(blockW / colsPerBlock) * 1

      let result_pixel = []
      let result_template = []

      // å…ˆæ¸…é™¤canvasä¸¦ç•«åŸåœ–
      const ctx = canvas.value.getContext('2d')
      /*canvas.value.width = imageData.width
      canvas.value.height = imageData.height
      ctx.putImageData(imageData, 0, 0)*/
	  canvas.value.width = src.cols
		canvas.value.height = src.rows
		cv.imshow(canvas.value, src)

      // è¨­å®šç´…ç·šæ¨£å¼
      ctx.strokeStyle = 'red'
        ctx.lineWidth = 2

        for (let block = 0; block < numBlocks; block++) {
          const blockX = block * blockW

          // è·³éæ¨™é¡Œè¡Œï¼Œè·‘25è¡Œ
          for (let i = 1; i < rowsPerBlock; i++) {
            let qIndex = block * questionsPerBlock + i
            let row_pixel = { question: qIndex, A:0, B:0, C:0, D:0 }

            for (let j = 1; j <= 4; j++) { // è·³éé¡Œè™Ÿæ¬„
            const x = Math.floor(blockX + j * cellW)
            const y = Math.floor(i * cellH)

            // ç•«ç´…æ¡†
            ctx.strokeRect(x, y, cellW, cellH)

            if (x + cellW <= thresh.cols && y + cellH <= thresh.rows) {
              const cell = thresh.roi(new cv.Rect(x, y, cellW, cellH))
              const whitePixels = cv.countNonZero(cell)
              console.log(i,j,whitePixels,cellW,cellH);
			  //ä¸€å€‹cellè£¡å¤§æ–¼å¤šå°‘æ¯”ä¾‹çš„pixel
			  var whitePixels_rate = whitePixels / (cellW * cellH);
              //row_pixel[['A','B','C','D'][j-1]] = whitePixels > 550 ? 1 : 0
			  row_pixel[['A','B','C','D'][j-1]] = whitePixels_rate > 0.1 ? 1 : 0
              
              cell.delete()
            } else {
              console.warn(`è·³éè¶…å‡ºç¯„åœ Q${qIndex} col ${j}`)
              row_pixel[['A','B','C','D'][j-1]] = 0
            }
            }
            result_pixel.push(row_pixel)
          }
        }

  // ------------ é¡Œè™Ÿ1æ¨¡æ¿åŒ¹é…å€å¡Š ---------------
  let templateMat = cv.imread(document.getElementById('templateImg'))
  let templateGray = new cv.Mat()
  cv.cvtColor(templateMat, templateGray, cv.COLOR_RGBA2GRAY)

  let matchResultCols = gray.cols - templateGray.cols + 1
  let matchResultRows = gray.rows - templateGray.rows + 1
  let matchResult = new cv.Mat()
  matchResult.create(matchResultRows, matchResultCols, cv.CV_32FC1)

  cv.matchTemplate(gray, templateGray, matchResult, cv.TM_CCOEFF_NORMED)
  let minMax = cv.minMaxLoc(matchResult)
  let maxLoc = minMax.maxLoc
  let maxVal = minMax.maxVal

  if (maxVal > 0.7) {
    ctx.strokeStyle = 'lime'
    ctx.lineWidth = 3
    ctx.strokeRect(maxLoc.x, maxLoc.y, templateGray.cols, templateGray.rows)
  }

  templateMat.delete()
  templateGray.delete()
  matchResult.delete()
  // ------------ æ¨¡æ¿åŒ¹é…çµæŸ ---------------------

  // è®€å–ç©ºç™½æ¨¡æ¿ä¸¦ç°éš+äºŒå€¼åŒ–
  let checktemplateMat = cv.imread(document.getElementById('nullImg'))
  let checktemplateGray = new cv.Mat()
  cv.cvtColor(checktemplateMat, checktemplateGray, cv.COLOR_RGBA2GRAY)
  cv.threshold(checktemplateGray, checktemplateGray, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU)

  const diffThreshold = 600 // å·®ç•°å°æ–¼é€™å€‹å€¼ï¼Œè¦–ç‚ºç©ºç™½æ ¼

  // ä¸»è¿´åœˆï¼šèµ°éæ‰€æœ‰æ ¼å­
  for (let block = 0; block < numBlocks; block++) {
    const blockX = block * blockW
    for (let i = 1; i < rowsPerBlock; i++) {
      let qIndex = block * questionsPerBlock + i
      let row_template = { question: qIndex, A: 0, B: 0, C: 0, D: 0 }

      for (let j = 1; j <= 4; j++) {
        const x = Math.floor(blockX + j * cellW)
        const y = Math.floor(i * cellH)

        ctx.strokeStyle = 'red'
        ctx.lineWidth = 2
        ctx.strokeRect(x, y, cellW, cellH)

        if (x + cellW <= gray.cols && y + cellH <= gray.rows) {
          const cellGray = gray.roi(new cv.Rect(x, y, cellW, cellH))
          const cellBinary = new cv.Mat()
          cv.threshold(cellGray, cellBinary, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU)

          const resizedCell = new cv.Mat()
          cv.resize(cellBinary, resizedCell, new cv.Size(checktemplateGray.cols, checktemplateGray.rows))

          const diff = new cv.Mat()
          cv.absdiff(resizedCell, checktemplateGray, diff)
          const diffPixels = cv.countNonZero(diff)
          //console.log(i, j, diffPixels);

          if (diffPixels < diffThreshold) {
            ctx.strokeStyle = 'lime'
            ctx.lineWidth = 2
            const offsetX = x + (cellW - checktemplateGray.cols) / 2
            const offsetY = y + (cellH - checktemplateGray.rows) / 2
            ctx.strokeRect(offsetX, offsetY, checktemplateGray.cols, checktemplateGray.rows)
            row_template[['A', 'B', 'C', 'D'][j - 1]] = 0
          } else {
            row_template[['A', 'B', 'C', 'D'][j - 1]] = 1
          }

          cellGray.delete()
          cellBinary.delete()
          resizedCell.delete()
          diff.delete()
        } else {
          console.warn(`è·³éè¶…å‡ºç¯„åœ Q${qIndex} col ${j}`)
          row_template[['A', 'B', 'C', 'D'][j - 1]] = 0
        }
      }
      result_template.push(row_template)
    }
  }

  checktemplateMat.delete()
  checktemplateGray.delete()
  detected_pixel.value = result_pixel
  detected_template.value = result_template
  src.delete()
  gray.delete()
  thresh.delete()
  alert('æƒæå®Œæˆï¼')
}

	
	const exportExcel = () => {
  if (detected_pixel.value.length === 0 || detected_template.value.length === 0) {
    alert('è«‹å…ˆæƒæï¼')
    return
  }

  const data = [['é¡Œè™Ÿ','A','B','C','D']]
  const ws = XLSX.utils.aoa_to_sheet(data)

  for (let i = 0; i < detected_pixel.value.length; i++) {
    const p = detected_pixel.value[i]
    const t = detected_template.value[i]

    let row = [p.question]
    for (let opt of ['A','B','C','D']) {
      let value = 0
      let mismatch = false

      if (exportMode.value === 'pixel') {
        value = p[opt]
      } else if (exportMode.value === 'template') {
        value = t[opt]
      } else if (exportMode.value === 'both') {
        value = (p[opt] === 1 && t[opt] === 1) ? 1 : 0
        mismatch = (p[opt] !== t[opt])
      }

      row.push(value)

      // æ¨™è¨˜
      if (exportMode.value === 'both' && mismatch) {
		  ws[cellAddress].v = value + '*'
		}
    }

    XLSX.utils.sheet_add_aoa(ws, [row], { origin: -1 })
  }

  const wb = XLSX.utils.book_new()
  XLSX.utils.book_append_sheet(wb, ws, 'Answers')
  XLSX.writeFile(wb, 'answers.xlsx')
}


	return { video, canvas, detected_pixel, detected_template, uploadedImage, handleFile, exportExcel, exportMode }
  }
}).mount('#app')
}
</script>

</body>
</html>
