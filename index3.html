<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>答案掃描器</title>
  <style>
    body { font-family: sans-serif; max-width: 800px; margin: auto; text-align: center; }
    .red-frame { position: absolute; top: 25%; left: 25%; width: 50%; height: 50%; border: 4px solid red; }
    .relative { position: relative; }
    video { width: 100%; }
    button, select, input[type="file"] { margin: 8px; padding: 8px 16px; font-size: 16px; }
    img.preview { max-width: 100%; margin-top: 8px; }
    canvas { max-width: 100%; margin-top: 8px; border: 1px solid #ccc; }
  </style>
  <!-- Vue -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <!-- SheetJS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
</head>
<body>

<div id="app">
  <h2>答案掃描器 Demo</h2>

  <!-- 將canvas改成顯示，方便看到紅框 -->
  <canvas ref="canvas"></canvas>

  <div>
    <!--<button @click="capture">開始掃描（相機）</button>-->
    <input type="file" accept="image/*" @change="handleFile">
    <button @click="exportExcel">匯出 Excel</button>
  </div>

<img id="templateImg" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAkACQAAD/2wBDAAIBAQIBAQICAgICAgICAwUDAwMDAwYEBAMFBwYHBwcGBwcICQsJCAgKCAcHCg0KCgsMDAwMBwkODw0MDgsMDAz/2wBDAQICAgMDAwYDAwYMCAcIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wAARCABGAF0DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9/KKKKACiiigAopC2DTZJQqZyPWgB9FMjcOxwQdpwfY/5xT6ACiiigAooooAKKKKACkfpS01zgUAfLH/BWb/gqh4J/wCCTn7OcPjjxdpupa9faxdnTNC0azwh1G82NIFkmOVhiUKS8m1yo+6jkhT/ADS/8FDv+C3f7Wf7W3jTSvGWr+KfHPwp8G6utxJ4W0rwvd3ui6VPAkgSR0uFZTfSIy7WlZmCuCEEanYP6p/2pf2I/hV+2nB4Yt/ip4L0vxtZeEdS/tbS7XUfMe2hufLZN8kQYRzJtYgxyo6E4JXKgj8Hf+D1zSrbQfjt8ArKzt4LK1tvDWoRw20MYjit0WeFQqAAAJhcAADoexFAH6tf8G33xJ8Q/F//AII1/B/xH4q13W/E2u6iNZFxqmr30l9eXQj1zUIk8yaQl22oiqATwqgV9yV8Af8ABrn/AMoKPgZ/3Hv/AFINSr7/AKACiiigAooooAKKKKACiikbpQAE81/OZ/we9f8AJx/wH/7FrUv/AEqir9Xv+C3v/BWC5/4JEfs6+F/HVt4Ig8eyeI/EiaD9gl1T+zljBtriff5gikyR5IAGDndX83P/AAWh/wCCxd3/AMFhviD4I1+88CWvgI+CrC509IrfVzqH2pZZlk3HMUWMbR25yfSgD+h3/g10OP8AghR8DP8AuPf+pBqdff8AX8u//BMb/g6W1D/gnD+xV4H+C9t8GrPxbaeEWvQdYfxGbSSf7TqFxeH9wLZxlftG0fOc461/UBYhtnzjDEDIByF9gcDIHPagCxRRRQAUUUUAFFFFABTZOn406igDmfib8J/DPxi0aLS/FvhrQvFOlxTC4W01axivIEkAKiQJIrLuAZhn0Y+tcPa/sI/BADafgz8Kl24+UeErEDOB0HlY9K9eooA8mh/YY+C2n3Uc9v8ACD4XQzRHcskfhSwV1PbB8rPvx3Ar1KzjMeQc/UgAn8uPb8Pep6KACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//9k=" style="display: none;">
<!--<img id="nullImg" style="display: none;" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAkACQAAD/2wBDAAIBAQIBAQICAgICAgICAwUDAwMDAwYEBAMFBwYHBwcGBwcICQsJCAgKCAcHCg0KCgsMDAwMBwkODw0MDgsMDAz/2wBDAQICAgMDAwYDAwYMCAcIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wAARCABZAF8DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9/BxRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH/2Q==">
 -->
 <img id="nullImg" style="display: none;" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAkACQAAD/2wBDAAIBAQIBAQICAgICAgICAwUDAwMDAwYEBAMFBwYHBwcGBwcICQsJCAgKCAcHCg0KCgsMDAwMBwkODw0MDgsMDAz/2wBDAQICAgMDAwYDAwYMCAcIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAz/wAARCAAnAC0DASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Z">
  <div v-if="uploadedImage">
    <h3>上傳圖片預覽</h3>
    <img :src="uploadedImage" class="preview">
  </div>

  <div v-if="detected.length > 0">
    <h3>偵測結果 (前10題預覽)</h3>
    <div v-for="row in detected.slice(0,10)" :key="row.question">
      第 {{ row.question }} 題：A={{row.A}} B={{row.B}} C={{row.C}} D={{row.D}}
    </div>
    <p>... 共 {{detected.length}} 題</p>
  </div>
</div>

<script>
// 等 OpenCV 載入完成再啟動 Vue
Module = {
  onRuntimeInitialized() {
    console.log('OpenCV ready!')
    startVue()
  }
}

function startVue() {
const { createApp, ref, onMounted } = Vue

createApp({
  setup() {
    const video = ref(null)
    const canvas = ref(null)
    const detected = ref([])
    const devices = ref([])
    const selectedDeviceId = ref('')
    const uploadedImage = ref(null)

    let currentStream = null

    const handleFile = (e) => {
      const file = e.target.files[0]
      if (!file) return
      const reader = new FileReader()
      reader.onload = () => {
        uploadedImage.value = reader.result
        const img = new Image()
        img.onload = () => {
          const ctx = canvas.value.getContext('2d')
          canvas.value.width = img.width
          canvas.value.height = img.height
          ctx.drawImage(img, 0, 0)
          const imageData = ctx.getImageData(0, 0, img.width, img.height)
          processImage(imageData)
        }
        img.src = reader.result
      }
      reader.readAsDataURL(file)
    }

    const processImage = (imageData) => {
	  let src = cv.matFromImageData(imageData)
	  let gray = new cv.Mat()
	  let thresh = new cv.Mat()
	  cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY)
	  cv.threshold(gray, thresh, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU)

	  // 原本切分紅線程式碼(你原本那段)保留
	  // 以下是複製你給的程式碼，沒改動
	  const numBlocks = 4
	  const questionsPerBlock = 25
	  const rowsPerBlock = 26   // 含標題行
	  const colsPerBlock = 5    // 題號+ABCD

	  const blockW = Math.floor(thresh.cols / numBlocks)
	  const blockH = thresh.rows

	  const cellH = Math.floor(blockH / rowsPerBlock) * 1.005
	  const cellW = Math.floor(blockW / colsPerBlock) * 1

	  let result = []

	  // 先清除canvas並畫原圖
	  const ctx = canvas.value.getContext('2d')
	  canvas.value.width = imageData.width
	  canvas.value.height = imageData.height
	  ctx.putImageData(imageData, 0, 0)

	  // 設定紅線樣式
	  ctx.strokeStyle = 'red'
	  ctx.lineWidth = 2

	  for (let block = 0; block < numBlocks; block++) {
		const blockX = block * blockW

		// 跳過標題行，跑25行
		for (let i = 1; i < rowsPerBlock; i++) {
		  let qIndex = block * questionsPerBlock + i
		  let row = { question: qIndex, A:0, B:0, C:0, D:0 }

		  for (let j = 1; j <= 4; j++) { // 跳過題號欄
			const x = Math.floor(blockX + j * cellW)
			const y = Math.floor(i * cellH)

			// 畫紅框
			ctx.strokeRect(x, y, cellW, cellH)

			if (x + cellW <= thresh.cols && y + cellH <= thresh.rows) {
			  const cell = thresh.roi(new cv.Rect(x, y, cellW, cellH))
			  const whitePixels = cv.countNonZero(cell)
			  
			  row[['A','B','C','D'][j-1]] = whitePixels > 550 ? 1 : 0
			  
			  cell.delete()
			} else {
			  console.warn(`跳過超出範圍 Q${qIndex} col ${j}`)
			  row[['A','B','C','D'][j-1]] = 0
			}
		  }
		  result.push(row)
		}
	  }

	  // --- 這裡開始加模板匹配判斷 ---
	  // 讀取模板 (先轉成灰階)
	  let templateMat = cv.imread(document.getElementById('templateImg'))
	  let templateGray = new cv.Mat()
	  cv.cvtColor(templateMat, templateGray, cv.COLOR_RGBA2GRAY)

	  // 執行模板匹配
	  let matchResultCols = thresh.cols - templateGray.cols + 1
	  let matchResultRows = thresh.rows - templateGray.rows + 1
	  let matchResult = new cv.Mat()
	  matchResult.create(matchResultRows, matchResultCols, cv.CV_32FC1)

	  cv.matchTemplate(gray, templateGray, matchResult, cv.TM_CCOEFF_NORMED)
	  
	  // 找到最佳匹配位置
	  let minMax = cv.minMaxLoc(matchResult)
	  let maxLoc = minMax.maxLoc
	  let maxVal = minMax.maxVal
	  
	  // 門檻值可調整，這裡設0.7，你可以根據情況調
	  if (maxVal > 0.7) {
		// 畫模板匹配框
		ctx.strokeStyle = 'lime'
		ctx.lineWidth = 3
		ctx.strokeRect(maxLoc.x, maxLoc.y, templateGray.cols, templateGray.rows)
	  }

	  // 釋放資源
	  templateMat.delete()
	  templateGray.delete()
	  matchResult.delete()
	  
	  // --- 這裡開始加模板匹配判斷 ---
	  // --- 這裡開始加模板匹配判斷 ---
	/*	// --- 空白模板比對開始 ---
		let checktemplateMat = cv.imread(document.getElementById('nullImg'))
		let checktemplateGray = new cv.Mat()
		cv.cvtColor(checktemplateMat, checktemplateGray, cv.COLOR_RGBA2GRAY)
		cv.threshold(checktemplateGray, checktemplateGray, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU)

		const blankMatchThreshold = 0.8

		for (let block = 0; block < numBlocks; block++) {
		  const blockX = block * blockW

		  for (let i = 1; i < rowsPerBlock; i++) {
			const qIndex = block * questionsPerBlock + i
			const resultIndex = result.findIndex(r => r.question === qIndex)

			for (let j = 1; j <= 4; j++) {
			  const x = Math.floor(blockX + j * cellW)
			  const y = Math.floor(i * cellH)

			  if (x + cellW <= gray.cols && y + cellH <= gray.rows) {
				const cell = gray.roi(new cv.Rect(x, y, cellW, cellH))
				const matchMat = new cv.Mat()
				const resultCols = cell.cols - checktemplateGray.cols + 1
				const resultRows = cell.rows - checktemplateGray.rows + 1
				matchMat.create(resultRows, resultCols, cv.CV_32FC1)

				cv.matchTemplate(cell, checktemplateGray, matchMat, cv.TM_CCOEFF_NORMED)
				const { maxVal } = cv.minMaxLoc(matchMat)

				const option = ['A', 'B', 'C', 'D'][j - 1]

				if (maxVal >= blankMatchThreshold) {
				  // 空白模板比對成功 → 此格是空白
				  result[resultIndex][option] = 0
				  ctx.strokeStyle = 'lime'
				  ctx.lineWidth = 2
				  ctx.strokeRect(x, y, cellW, cellH)
				} else {
				  // 比對失敗 → 被打勾
				  result[resultIndex][option] = 1
				  // 不畫框，維持紅框結構清楚
				}

				cell.delete()
				matchMat.delete()
			  }
			}
		  }
		}

		checktemplateMat.delete()
		checktemplateGray.delete()
*/

	  detected.value = result
	  src.delete(); gray.delete(); thresh.delete()
	  alert('掃描完成！')
	}


    const exportExcel = () => {
      if (detected.value.length === 0) {
        alert('請先掃描！')
        return
      }
      const data = [['題號','A','B','C','D']]
      detected.value.forEach(r => data.push([r.question, r.A, r.B, r.C, r.D]))
      const ws = XLSX.utils.aoa_to_sheet(data)
      const wb = XLSX.utils.book_new()
      XLSX.utils.book_append_sheet(wb, ws, 'Answers')
      XLSX.writeFile(wb, 'answers.xlsx')
    }
	
	let templateMat = null

	function loadTemplateMat() {
	  return new Promise((resolve) => {
		const imgElement = document.getElementById('templateImg')
		imgElement.onload = () => {
		  templateMat = cv.imread(imgElement)
		  // 可轉成灰階以利匹配（跟你的processImage保持一致）
		  let tempGray = new cv.Mat()
		  cv.cvtColor(templateMat, tempGray, cv.COLOR_RGBA2GRAY)
		  cv.threshold(tempGray, templateMat, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU)
		  tempGray.delete()
		  resolve()
		}
		// 如果已經載入過，直接讀取
		if (imgElement.complete && imgElement.naturalHeight !== 0) {
		  templateMat = cv.imread(imgElement)
		  let tempGray = new cv.Mat()
		  cv.cvtColor(templateMat, tempGray, cv.COLOR_RGBA2GRAY)
		  cv.threshold(tempGray, templateMat, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU)
		  tempGray.delete()
		  resolve()
		}
	  })
	}

	return { video, canvas, detected, uploadedImage, handleFile, exportExcel }
  }
}).mount('#app')
}
</script>

</body>
</html>
