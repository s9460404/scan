<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <title>答案掃描器 Demo</title>
  <style>
    body { font-family: sans-serif; max-width: 600px; margin: auto; text-align: center; }
    .red-frame { position: absolute; top: 25%; left: 25%; width: 50%; height: 50%; border: 4px solid red; }
    .relative { position: relative; }
    video { width: 100%; }
    button { margin: 8px; padding: 8px 16px; font-size: 16px; }
  </style>
  <!-- Vue -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <!-- SheetJS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
</head>
<body>
<div id="app">
  <h2>答案掃描器 Demo</h2>
  <div class="relative">
    <video ref="video" autoplay playsinline></video>
    <div class="red-frame"></div>
  </div>
  <canvas ref="canvas" style="display:none;"></canvas>
  <div>
    <button @click="capture">開始掃描</button>
    <button @click="exportExcel">匯出 Excel</button>
  </div>
  <div v-if="detected.length > 0">
    <h3>偵測結果</h3>
    <div v-for="row in detected" :key="row.question">
      第 {{ row.question }} 題：A={{row.A}} B={{row.B}} C={{row.C}} D={{row.D}}
    </div>
  </div>
</div>

<script>
const { createApp, ref, onMounted } = Vue

createApp({
  setup() {
    const video = ref(null)
    const canvas = ref(null)
    const detected = ref([])

    onMounted(async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
		  video: { facingMode: { exact: "environment" } }
		})
        video.value.srcObject = stream
      } catch (e) {
        alert('無法取得相機：' + e)
      }
    })

    const capture = () => {
      if (!cv || !cv.imread) {
        alert('OpenCV 尚未加載完成，請稍後再試')
        return
      }

      const ctx = canvas.value.getContext('2d')
      canvas.value.width = video.value.videoWidth
      canvas.value.height = video.value.videoHeight
      ctx.drawImage(video.value, 0, 0, canvas.value.width, canvas.value.height)

      const x=canvas.value.width*0.25, y=canvas.value.height*0.25, w=canvas.value.width*0.5, h=canvas.value.height*0.5
      const cropped = ctx.getImageData(x, y, w, h)

      processImage(cropped)
    }

    const processImage = (imageData) => {
      let src = cv.matFromImageData(imageData)
      let gray = new cv.Mat()
      let thresh = new cv.Mat()
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY)
      cv.threshold(gray, thresh, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU)

      const numQuestions = 3   // 假設先偵測 3 題
      const numOptions = 4     // A B C D
      const cellH = Math.floor(thresh.rows / numQuestions)
      const cellW = Math.floor(thresh.cols / numOptions)

      let result = []

      for (let i = 0; i < numQuestions; i++) {
        let row = { question: i+1, A:0, B:0, C:0, D:0 }
        for (let j = 0; j < numOptions; j++) {
          const cell = thresh.roi(new cv.Rect(j*cellW, i*cellH, cellW, cellH))
          const black = cv.countNonZero(cell)
          cell.delete()
          // 如果黑點數量超過門檻就視為有勾選
          row[['A','B','C','D'][j]] = black > 1000 ? 1 : 0
        }
        result.push(row)
      }

      detected.value = result

      src.delete(); gray.delete(); thresh.delete()

      alert('掃描完成！')
    }

    const exportExcel = () => {
      if (detected.value.length === 0) {
        alert('請先掃描！')
        return
      }
      const data = [['題號','A','B','C','D']]
      detected.value.forEach(r => data.push([r.question, r.A, r.B, r.C, r.D]))
      const ws = XLSX.utils.aoa_to_sheet(data)
      const wb = XLSX.utils.book_new()
      XLSX.utils.book_append_sheet(wb, ws, 'Answers')
      XLSX.writeFile(wb, 'answers.xlsx')
    }

    return { video, canvas, detected, capture, exportExcel }
  }
}).mount('#app')
</script>
</body>
</html>
