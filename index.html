<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>答案掃描器 Demo</title>
  <style>
    body { font-family: sans-serif; max-width: 600px; margin: auto; text-align: center; }
    .red-frame { position: absolute; top: 25%; left: 25%; width: 50%; height: 50%; border: 4px solid red; }
    .relative { position: relative; }
    video { width: 100%; }
    button, select { margin: 8px; padding: 8px 16px; font-size: 16px; }
  </style>
  <!-- Vue -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <!-- SheetJS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
</head>
<body>

<div id="app">
  <h2>答案掃描器 Demo</h2>

  <div>
    <label for="cameraSelect">選擇相機：</label>
    <select id="cameraSelect" v-model="selectedDeviceId" @change="startCamera">
      <option v-for="d in devices" :key="d.deviceId" :value="d.deviceId">
        {{ d.label || 'Camera ' + d.deviceId }}
      </option>
    </select>
  </div>

  <div class="relative">
    <video ref="video" autoplay playsinline></video>
    <div class="red-frame"></div>
  </div>
  <canvas ref="canvas" style="display: none;"></canvas>

  <div>
    <button @click="capture">開始掃描</button>
    <button @click="exportExcel">匯出 Excel</button>
  </div>

  <div v-if="detected.length > 0">
    <h3>偵測結果</h3>
    <div v-for="row in detected" :key="row.question">
      第 {{ row.question }} 題：A={{row.A}} B={{row.B}} C={{row.C}} D={{row.D}}
    </div>
  </div>
</div>

<script>
const { createApp, ref, onMounted, watch } = Vue

createApp({
  setup() {
    const video = ref(null)
    const canvas = ref(null)
    const detected = ref([])
    const devices = ref([])
    const selectedDeviceId = ref('')

    let currentStream = null

    onMounted(async () => {
      try {
        // 先取得相機權限，讓 label 有值
        const tempStream = await navigator.mediaDevices.getUserMedia({ video: true })
        tempStream.getTracks().forEach(t => t.stop())

        const allDevices = await navigator.mediaDevices.enumerateDevices()
        const videoDevices = allDevices.filter(d => d.kind === 'videoinput')
        devices.value = videoDevices

        if (videoDevices.length > 0) {
          selectedDeviceId.value = videoDevices[0].deviceId
          await startCamera()  // 預設啟動第一台相機
        }
      } catch (e) {
        alert('無法取得相機：' + e)
        console.error(e)
      }
    })

    const startCamera = async () => {
      try {
        if (currentStream) {
          currentStream.getTracks().forEach(track => track.stop())
        }
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { deviceId: { exact: selectedDeviceId.value } }
        })
        video.value.srcObject = stream
        currentStream = stream
      } catch (e) {
        alert('啟動相機失敗：' + e)
        console.error(e)
      }
    }

    const capture = () => {
      if (!cv || !cv.imread) {
        alert('OpenCV 尚未加載完成，請稍後再試')
        return
      }
      const ctx = canvas.value.getContext('2d')
      canvas.value.width = video.value.videoWidth
      canvas.value.height = video.value.videoHeight
      ctx.drawImage(video.value, 0, 0, canvas.value.width, canvas.value.height)

      const x = canvas.value.width * 0.25
      const y = canvas.value.height * 0.25
      const w = canvas.value.width * 0.5
      const h = canvas.value.height * 0.5
      const cropped = ctx.getImageData(x, y, w, h)

      processImage(cropped)
    }

    const processImage = (imageData) => {
      let src = cv.matFromImageData(imageData)
      let gray = new cv.Mat()
      let thresh = new cv.Mat()
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY)
      cv.threshold(gray, thresh, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU)

      const numQuestions = 3   // 測試用
      const numOptions = 4     // A/B/C/D
      const cellH = Math.floor(thresh.rows / numQuestions)
      const cellW = Math.floor(thresh.cols / numOptions)

      let result = []

      for (let i = 0; i < numQuestions; i++) {
        let row = { question: i+1, A:0, B:0, C:0, D:0 }
        for (let j = 0; j < numOptions; j++) {
          const cell = thresh.roi(new cv.Rect(j*cellW, i*cellH, cellW, cellH))
          const black = cv.countNonZero(cell)
          cell.delete()
          row[['A','B','C','D'][j]] = black > 1000 ? 1 : 0
        }
        result.push(row)
      }

      detected.value = result
      src.delete(); gray.delete(); thresh.delete()
      alert('掃描完成！')
    }

    const exportExcel = () => {
      if (detected.value.length === 0) {
        alert('請先掃描！')
        return
      }
      const data = [['題號','A','B','C','D']]
      detected.value.forEach(r => data.push([r.question, r.A, r.B, r.C, r.D]))
      const ws = XLSX.utils.aoa_to_sheet(data)
      const wb = XLSX.utils.book_new()
      XLSX.utils.book_append_sheet(wb, ws, 'Answers')
      XLSX.writeFile(wb, 'answers.xlsx')
    }

    return { video, canvas, detected, devices, selectedDeviceId, capture, exportExcel, startCamera }
  }
}).mount('#app')
</script>

</body>
</html>
